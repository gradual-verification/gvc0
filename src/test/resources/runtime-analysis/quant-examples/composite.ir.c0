#use <stress>
struct Node;

struct Node
{
  int total;
  struct Node* left;
  struct Node* right;
  struct Node* parent;
};

//@predicate context(struct Node* node, struct Node* parent, int total);
//@predicate subtreeHelper(struct Node* l, struct Node* r, struct Node* parent, int total);
//@predicate tree(struct Node* node);

//@predicate context(struct Node* node, struct Node* parent, int total) = parent == NULL ? true : acc(parent->left) && acc(parent->right) && acc(parent->parent) && acc(parent->total) && context(parent, parent->parent, parent->total) && (node == parent->left ? parent->right == NULL ? parent->total == 1 + total : acc(parent->right->left) && acc(parent->right->right) && acc(parent->right->parent) && acc(parent->right->total) && parent->right->parent == parent && subtreeHelper(parent->right->left, parent->right->right, parent->right, parent->right->total) && parent->total == 1 + total + parent->right->total : node == parent->right && (parent->left == NULL ? parent->total == 1 + total : acc(parent->left->left) && acc(parent->left->right) && acc(parent->left->parent) && acc(parent->left->total) && parent->left->parent == parent && subtreeHelper(parent->left->left, parent->left->right, parent->left, parent->left->total) && parent->total == 1 + total + parent->left->total));
//@predicate subtreeHelper(struct Node* l, struct Node* r, struct Node* parent, int total) = l == NULL ? r == NULL ? total == 1 : acc(r->left) && acc(r->right) && acc(r->parent) && acc(r->total) && r->parent == parent && subtreeHelper(r->left, r->right, r, r->total) && total == 1 + r->total : r == NULL ? acc(l->left) && acc(l->right) && acc(l->parent) && acc(l->total) && l->parent == parent && subtreeHelper(l->left, l->right, l, l->total) && total == 1 + l->total : acc(r->left) && acc(r->right) && acc(r->parent) && acc(r->total) && r->parent == parent && subtreeHelper(r->left, r->right, r, r->total) && acc(l->left) && acc(l->right) && acc(l->parent) && acc(l->total) && l->parent == parent && subtreeHelper(l->left, l->right, l, l->total) && total == 1 + l->total + r->total;
//@predicate tree(struct Node* node) = node == NULL ? true : acc(node->left) && acc(node->right) && acc(node->parent) && acc(node->total) && context(node, node->parent, node->total) && subtreeHelper(node->left, node->right, node, node->total);

struct Node* create_tree();
int fixup_ancestors(struct Node* node, struct Node* parent, int oldTotal, int newTotal);
int main();
struct Node* tree_add_left(struct Node* node);
struct Node* tree_add_right(struct Node* node);
struct Node* tree_get_left(struct Node* node);
struct Node* tree_get_parent(struct Node* node);
struct Node* tree_get_right(struct Node* node);
int tree_get_total(struct Node* node);
bool tree_has_left(struct Node* node);
bool tree_has_parent(struct Node* node);
bool tree_has_right(struct Node* node);

struct Node* create_tree()
  //@requires true;
  //@ensures tree(\result);
{
  struct Node* n = NULL;
  n = alloc(struct Node);
  n->left = NULL;
  n->right = NULL;
  n->parent = NULL;
  n->total = 1;
  //@fold subtreeHelper(n->left, n->right, n, n->total);
  //@fold context(n, n->parent, n->total);
  //@fold tree(n);
  return n;
}

int fixup_ancestors(struct Node* node, struct Node* parent, int oldTotal, int newTotal)
  //@requires context(node, parent, oldTotal);
  //@ensures context(node, parent, newTotal);
{
  struct Node* left = NULL;
  struct Node* right = NULL;
  struct Node* grandparent = NULL;
  int oldparentTotal = 0;
  int leftTotal = 0;
  int rightTotal = 0;
  int parentTotal = 0;
  //@unfold context(node, parent, oldTotal);
  if (parent == NULL)
  {
  }
  else
  {
    left = parent->left;
    right = parent->right;
    grandparent = parent->parent;
    oldparentTotal = parent->total;
    leftTotal = 0;
    rightTotal = 0;
    if (node == left)
    {
      leftTotal = newTotal;
      if (right != NULL)
      {
        rightTotal = right->total;
      }
    }
    else
    {
      if (left != NULL)
      {
        leftTotal = left->total;
      }
      rightTotal = newTotal;
    }
    parentTotal = 1 + leftTotal + rightTotal;
    parent->total = parentTotal;
    fixup_ancestors(parent, grandparent, oldparentTotal, parentTotal);
  }
  //@fold context(node, parent, newTotal);
  return 0;
}

int main()
  //@requires true;
  //@ensures true;
{
  int stress = 0;
  int stressCaptured = 0;
  int seed = 0;
  struct Node* node = NULL;
  int i = 0;
  struct Node* current = NULL;
  bool _ = false;
  bool _1 = false;
  int r = 0;
  bool rand_bool = false;
  int _2 = 0;
  bool _3 = false;
  bool _4 = false;
  int r1 = 0;
  bool rand_bool1 = false;
  int _5 = 0;
  bool _6 = false;
  struct Node* current1 = NULL;
  struct Node* current2 = NULL;
  struct Node* current21 = NULL;
  stress = 0;
  stressCaptured = stress + stress / 2 * 2;
  seed = 1;
  node = create_tree();
  i = 0;
  while (i < stressCaptured)
    //@loop_invariant 0 <= i && i <= stressCaptured && tree(node);
  {
    current = node;
    _ = tree_has_left(current);
    if (_)
    {
      _1 = tree_has_right(current);
    }
    while (_ && _1)
      //@loop_invariant tree(current);
    {
      r = rand(seed);
      seed = r;
      _2 = mod(seed, stressCaptured);
      rand_bool = _2 <= stressCaptured / 2;
      if (rand_bool)
      {
        current1 = tree_get_left(current);
      }
      else
      {
        current1 = tree_get_right(current);
      }
      _ = tree_has_left(current1);
      if (_)
      {
        _1 = tree_has_right(current1);
      }
      current = current1;
    }
    _3 = tree_has_left(current);
    if (_3)
    {
      current2 = tree_add_right(current);
    }
    else
    {
      _4 = tree_has_right(current);
      if (_4)
      {
        current2 = tree_add_left(current);
      }
      else
      {
        r1 = rand(seed);
        seed = r1;
        _5 = mod(seed, stressCaptured);
        rand_bool1 = _5 <= stressCaptured / 2;
        if (rand_bool1)
        {
          current2 = tree_add_right(current);
        }
        else
        {
          current2 = tree_add_left(current);
        }
      }
    }
    _6 = tree_has_parent(current2);
    while (_6)
      //@loop_invariant tree(current2);
    {
      current21 = tree_get_parent(current2);
      _6 = tree_has_parent(current21);
      current2 = current21;
    }
    node = current2;
    i = i + 1;
    current = current2;
  }
  return 0;
}

struct Node* tree_add_left(struct Node* node)
  //@requires tree(node);
  //@ensures tree(\result);
{
  struct Node* n = NULL;
  struct Node* nodeLeft = NULL;
  //@unfold tree(node);
  if (node == NULL)
  {
    //@fold tree(node);
    return node;
  }
  else
  {
    n = alloc(struct Node);
    n->left = NULL;
    n->right = NULL;
    n->parent = node;
    n->total = 1;
    //@fold subtreeHelper(n->left, n->right, n, n->total);
    nodeLeft = node->left;
    if (nodeLeft != NULL)
    {
      //@fold tree(node);
      return node;
    }
    else
    {
      //@unfold subtreeHelper(nodeLeft, node->right, node, node->total);
      node->left = n;
      //@fold context(n, node, 0);
      fixup_ancestors(n, node, 0, 1);
      //@fold tree(n);
      return n;
    }
  }
}

struct Node* tree_add_right(struct Node* node)
  //@requires tree(node);
  //@ensures tree(\result);
{
  struct Node* n = NULL;
  struct Node* nodeRight = NULL;
  //@unfold tree(node);
  if (node == NULL)
  {
    //@fold tree(node);
    return node;
  }
  else
  {
    n = alloc(struct Node);
    n->left = NULL;
    n->right = NULL;
    n->parent = node;
    n->total = 1;
    //@fold subtreeHelper(n->left, n->right, n, n->total);
    nodeRight = node->right;
    if (nodeRight != NULL)
    {
      //@fold tree(node);
      return node;
    }
    else
    {
      //@unfold subtreeHelper(node->left, nodeRight, node, node->total);
      node->right = n;
      //@fold context(n, node, 0);
      fixup_ancestors(n, node, 0, 1);
      //@fold tree(n);
      return n;
    }
  }
}

struct Node* tree_get_left(struct Node* node)
  //@requires tree(node);
  //@ensures tree(\result);
{
  struct Node* left = NULL;
  //@unfold tree(node);
  if (node == NULL)
  {
    //@fold tree(NULL);
    return NULL;
  }
  else
  {
    left = node->left;
    if (left != NULL)
    {
      //@unfold subtreeHelper(left, node->right, node, node->total);
      //@fold context(left, node, left->total);
    }
    //@fold tree(left);
    return left;
  }
}

struct Node* tree_get_parent(struct Node* node)
  //@requires tree(node);
  //@ensures tree(\result);
{
  struct Node* parent = NULL;
  //@unfold tree(node);
  if (node == NULL)
  {
    //@fold tree(NULL);
    return NULL;
  }
  else
  {
    parent = node->parent;
    if (parent == NULL)
    {
      //@fold tree(NULL);
      return NULL;
    }
    else
    {
      //@unfold context(node, parent, node->total);
      //@assert context(parent, parent->parent, parent->total);
      //@fold subtreeHelper(parent->left, parent->right, parent, parent->total);
      //@fold tree(parent);
      return parent;
    }
  }
}

struct Node* tree_get_right(struct Node* node)
  //@requires tree(node);
  //@ensures tree(\result);
{
  struct Node* right = NULL;
  //@unfold tree(node);
  if (node == NULL)
  {
    //@fold tree(NULL);
    return NULL;
  }
  else
  {
    right = node->right;
    if (right != NULL)
    {
      //@unfold subtreeHelper(node->left, right, node, node->total);
      //@fold context(right, node, right->total);
    }
    //@fold tree(right);
    return right;
  }
}

int tree_get_total(struct Node* node)
  //@requires tree(node);
  //@ensures tree(node);
{
  int result = 0;
  //@unfold tree(node);
  result = 0;
  if (node == NULL)
  {
  }
  else
  {
    result = node->total;
  }
  //@fold tree(node);
  return result;
}

bool tree_has_left(struct Node* node)
  //@requires tree(node);
  //@ensures tree(node);
{
  bool res = false;
  struct Node* left = NULL;
  //@unfold tree(node);
  res = false;
  if (node == NULL)
  {
  }
  else
  {
    left = node->left;
    res = left != NULL;
  }
  //@fold tree(node);
  return res;
}

bool tree_has_parent(struct Node* node)
  //@requires tree(node);
  //@ensures tree(node);
{
  bool res = false;
  struct Node* parent = NULL;
  //@unfold tree(node);
  res = false;
  if (node == NULL)
  {
  }
  else
  {
    parent = node->parent;
    res = parent != NULL;
  }
  //@fold tree(node);
  return res;
}

bool tree_has_right(struct Node* node)
  //@requires tree(node);
  //@ensures tree(node);
{
  bool res = false;
  struct Node* right = NULL;
  //@unfold tree(node);
  res = false;
  if (node == NULL)
  {
  }
  else
  {
    right = node->right;
    res = right != NULL;
  }
  //@fold tree(node);
  return res;
}
