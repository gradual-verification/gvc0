#use <runtime>
#use <stress>
struct Node;

struct Node
{
  int total;
  struct Node* left;
  struct Node* right;
  struct Node* parent;
  int _id;
};

struct Node* create_tree(int* _instanceCounter);
int fixup_ancestors(struct Node* node, struct Node* parent, int oldTotal, int newTotal, int* _instanceCounter);
int main();
struct Node* tree_add_left(struct Node* node, int* _instanceCounter);
struct Node* tree_add_right(struct Node* node, int* _instanceCounter);
struct Node* tree_get_left(struct Node* node, int* _instanceCounter);
struct Node* tree_get_parent(struct Node* node, int* _instanceCounter);
struct Node* tree_get_right(struct Node* node, int* _instanceCounter);
int tree_get_total(struct Node* node, int* _instanceCounter);
bool tree_has_left(struct Node* node, int* _instanceCounter);
bool tree_has_parent(struct Node* node, int* _instanceCounter);
bool tree_has_right(struct Node* node, int* _instanceCounter);

struct Node* create_tree(int* _instanceCounter)
{
  struct Node* n = NULL;
  n = alloc(struct Node);
  n->_id = *_instanceCounter;
  *_instanceCounter = *_instanceCounter + 1;
  n->left = NULL;
  n->right = NULL;
  n->parent = NULL;
  n->total = 1;
  return n;
}

int fixup_ancestors(struct Node* node, struct Node* parent, int oldTotal, int newTotal, int* _instanceCounter)
{
  struct Node* left = NULL;
  struct Node* right = NULL;
  struct Node* grandparent = NULL;
  int oldparentTotal = 0;
  int leftTotal = 0;
  int rightTotal = 0;
  int parentTotal = 0;
  if (parent == NULL)
  {
  }
  else
  {
    left = parent->left;
    right = parent->right;
    grandparent = parent->parent;
    oldparentTotal = parent->total;
    leftTotal = 0;
    rightTotal = 0;
    if (node == left)
    {
      leftTotal = newTotal;
      if (right != NULL)
      {
        rightTotal = right->total;
      }
    }
    else
    {
      if (left != NULL)
      {
        leftTotal = left->total;
      }
      rightTotal = newTotal;
    }
    parentTotal = 1 + leftTotal + rightTotal;
    parent->total = parentTotal;
    fixup_ancestors(parent, grandparent, oldparentTotal, parentTotal, _instanceCounter);
  }
  return 0;
}

int main()
{
  int stress = 0;
  int stressCaptured = 0;
  int seed = 0;
  struct Node* node = NULL;
  int i = 0;
  struct Node* current = NULL;
  bool _ = false;
  bool _1 = false;
  int r = 0;
  bool rand_bool = false;
  int _2 = 0;
  bool _3 = false;
  bool _4 = false;
  int r1 = 0;
  bool rand_bool1 = false;
  int _5 = 0;
  bool _6 = false;
  struct Node* current1 = NULL;
  struct Node* current2 = NULL;
  struct Node* current21 = NULL;
  int* _instanceCounter = NULL;
  _instanceCounter = alloc(int);
  stress = 0;
  stressCaptured = stress + stress / 2 * 2;
  seed = 1;
  node = create_tree(_instanceCounter);
  i = 0;
  while (i < stressCaptured)
  {
    current = node;
    _ = tree_has_left(current, _instanceCounter);
    if (_)
    {
      _1 = tree_has_right(current, _instanceCounter);
    }
    while (_ && _1)
    {
      r = rand(seed);
      seed = r;
      _2 = mod(seed, stressCaptured);
      rand_bool = _2 <= stressCaptured / 2;
      if (rand_bool)
      {
        current1 = tree_get_left(current, _instanceCounter);
      }
      else
      {
        current1 = tree_get_right(current, _instanceCounter);
      }
      _ = tree_has_left(current1, _instanceCounter);
      if (_)
      {
        _1 = tree_has_right(current1, _instanceCounter);
      }
      current = current1;
    }
    _3 = tree_has_left(current, _instanceCounter);
    if (_3)
    {
      current2 = tree_add_right(current, _instanceCounter);
    }
    else
    {
      _4 = tree_has_right(current, _instanceCounter);
      if (_4)
      {
        current2 = tree_add_left(current, _instanceCounter);
      }
      else
      {
        r1 = rand(seed);
        seed = r1;
        _5 = mod(seed, stressCaptured);
        rand_bool1 = _5 <= stressCaptured / 2;
        if (rand_bool1)
        {
          current2 = tree_add_right(current, _instanceCounter);
        }
        else
        {
          current2 = tree_add_left(current, _instanceCounter);
        }
      }
    }
    _6 = tree_has_parent(current2, _instanceCounter);
    while (_6)
    {
      current21 = tree_get_parent(current2, _instanceCounter);
      _6 = tree_has_parent(current21, _instanceCounter);
      current2 = current21;
    }
    node = current2;
    i = i + 1;
    current = current2;
  }
  return 0;
}

struct Node* tree_add_left(struct Node* node, int* _instanceCounter)
{
  struct Node* n = NULL;
  struct Node* nodeLeft = NULL;
  if (node == NULL)
  {
    return node;
  }
  else
  {
    n = alloc(struct Node);
    n->_id = *_instanceCounter;
    *_instanceCounter = *_instanceCounter + 1;
    n->left = NULL;
    n->right = NULL;
    n->parent = node;
    n->total = 1;
    nodeLeft = node->left;
    if (nodeLeft != NULL)
    {
      return node;
    }
    else
    {
      node->left = n;
      fixup_ancestors(n, node, 0, 1, _instanceCounter);
      return n;
    }
  }
}

struct Node* tree_add_right(struct Node* node, int* _instanceCounter)
{
  struct Node* n = NULL;
  struct Node* nodeRight = NULL;
  if (node == NULL)
  {
    return node;
  }
  else
  {
    n = alloc(struct Node);
    n->_id = *_instanceCounter;
    *_instanceCounter = *_instanceCounter + 1;
    n->left = NULL;
    n->right = NULL;
    n->parent = node;
    n->total = 1;
    nodeRight = node->right;
    if (nodeRight != NULL)
    {
      return node;
    }
    else
    {
      node->right = n;
      fixup_ancestors(n, node, 0, 1, _instanceCounter);
      return n;
    }
  }
}

struct Node* tree_get_left(struct Node* node, int* _instanceCounter)
{
  struct Node* left = NULL;
  if (node == NULL)
  {
    return NULL;
  }
  else
  {
    left = node->left;
    if (left != NULL)
    {
    }
    return left;
  }
}

struct Node* tree_get_parent(struct Node* node, int* _instanceCounter)
{
  struct Node* parent = NULL;
  if (node == NULL)
  {
    return NULL;
  }
  else
  {
    parent = node->parent;
    if (parent == NULL)
    {
      return NULL;
    }
    else
    {
      return parent;
    }
  }
}

struct Node* tree_get_right(struct Node* node, int* _instanceCounter)
{
  struct Node* right = NULL;
  if (node == NULL)
  {
    return NULL;
  }
  else
  {
    right = node->right;
    if (right != NULL)
    {
    }
    return right;
  }
}

int tree_get_total(struct Node* node, int* _instanceCounter)
{
  int result = 0;
  result = 0;
  if (node == NULL)
  {
  }
  else
  {
    result = node->total;
  }
  return result;
}

bool tree_has_left(struct Node* node, int* _instanceCounter)
{
  bool res = false;
  struct Node* left = NULL;
  res = false;
  if (node == NULL)
  {
  }
  else
  {
    left = node->left;
    res = left != NULL;
  }
  return res;
}

bool tree_has_parent(struct Node* node, int* _instanceCounter)
{
  bool res = false;
  struct Node* parent = NULL;
  res = false;
  if (node == NULL)
  {
  }
  else
  {
    parent = node->parent;
    res = parent != NULL;
  }
  return res;
}

bool tree_has_right(struct Node* node, int* _instanceCounter)
{
  bool res = false;
  struct Node* right = NULL;
  res = false;
  if (node == NULL)
  {
  }
  else
  {
    right = node->right;
    res = right != NULL;
  }
  return res;
}
