field Node$left: Ref

field Node$parent: Ref

field Node$right: Ref

field Node$total: Int

predicate context(node: Ref, parent: Ref, total: Int) {
  (parent == null ? true : acc(parent.Node$left, write) && acc(parent.Node$right, write) && acc(parent.Node$parent, write) && acc(parent.Node$total, write) && acc(context(parent, parent.Node$parent, parent.Node$total), write) && (node == parent.Node$left ? (parent.Node$right == null ? parent.Node$total == 1 + total : acc(parent.Node$right.Node$left, write) && acc(parent.Node$right.Node$right, write) && acc(parent.Node$right.Node$parent, write) && acc(parent.Node$right.Node$total, write) && parent.Node$right.Node$parent == parent && acc(subtreeHelper(parent.Node$right.Node$left, parent.Node$right.Node$right, parent.Node$right, parent.Node$right.Node$total), write) && parent.Node$total == 1 + total + parent.Node$right.Node$total) : node == parent.Node$right && (parent.Node$left == null ? parent.Node$total == 1 + total : acc(parent.Node$left.Node$left, write) && acc(parent.Node$left.Node$right, write) && acc(parent.Node$left.Node$parent, write) && acc(parent.Node$left.Node$total, write) && parent.Node$left.Node$parent == parent && acc(subtreeHelper(parent.Node$left.Node$left, parent.Node$left.Node$right, parent.Node$left, parent.Node$left.Node$total), write) && parent.Node$total == 1 + total + parent.Node$left.Node$total)))
}

predicate subtreeHelper(l: Ref, r: Ref, parent: Ref, total: Int) {
  (l == null ? (r == null ? total == 1 : acc(r.Node$left, write) && acc(r.Node$right, write) && acc(r.Node$parent, write) && acc(r.Node$total, write) && r.Node$parent == parent && acc(subtreeHelper(r.Node$left, r.Node$right, r, r.Node$total), write) && total == 1 + r.Node$total) : (r == null ? acc(l.Node$left, write) && acc(l.Node$right, write) && acc(l.Node$parent, write) && acc(l.Node$total, write) && l.Node$parent == parent && acc(subtreeHelper(l.Node$left, l.Node$right, l, l.Node$total), write) && total == 1 + l.Node$total : acc(r.Node$left, write) && acc(r.Node$right, write) && acc(r.Node$parent, write) && acc(r.Node$total, write) && r.Node$parent == parent && acc(subtreeHelper(r.Node$left, r.Node$right, r, r.Node$total), write) && acc(l.Node$left, write) && acc(l.Node$right, write) && acc(l.Node$parent, write) && acc(l.Node$total, write) && l.Node$parent == parent && acc(subtreeHelper(l.Node$left, l.Node$right, l, l.Node$total), write) && total == 1 + l.Node$total + r.Node$total))
}

predicate tree(node: Ref) {
  (node == null ? true : acc(node.Node$left, write) && acc(node.Node$right, write) && acc(node.Node$parent, write) && acc(node.Node$total, write) && acc(context(node, node.Node$parent, node.Node$total), write) && acc(subtreeHelper(node.Node$left, node.Node$right, node, node.Node$total), write))
}

method create_tree() returns ($result: Ref)
  requires true
  ensures acc(tree($result), write)
{
  var n: Ref
  n := new(Node$total, Node$left, Node$right, Node$parent)
  n.Node$left := null
  n.Node$right := null
  n.Node$parent := null
  n.Node$total := 1
  fold acc(subtreeHelper(n.Node$left, n.Node$right, n, n.Node$total), write)
  fold acc(context(n, n.Node$parent, n.Node$total), write)
  fold acc(tree(n), write)
  $result := n
}

method fixup_ancestors(node: Ref, parent: Ref, oldTotal: Int, newTotal: Int) returns ($result: Int)
  requires acc(context(node, parent, oldTotal), write)
  ensures acc(context(node, parent, newTotal), write)
{
  var left: Ref
  var right: Ref
  var grandparent: Ref
  var oldparentTotal: Int
  var leftTotal: Int
  var rightTotal: Int
  var parentTotal: Int
  var $result_0: Int
  unfold acc(context(node, parent, oldTotal), write)
  if (parent == null) {
    
  } else {
    left := parent.Node$left
    right := parent.Node$right
    grandparent := parent.Node$parent
    oldparentTotal := parent.Node$total
    leftTotal := 0
    rightTotal := 0
    if (node == left) {
      leftTotal := newTotal
      if (right != null) {
        rightTotal := right.Node$total
      }
    } else {
      if (left != null) {
        leftTotal := left.Node$total
      }
      rightTotal := newTotal
    }
    parentTotal := 1 + leftTotal + rightTotal
    parent.Node$total := parentTotal
    $result_0 := fixup_ancestors(parent, grandparent, oldparentTotal, parentTotal)
  }
  fold acc(context(node, parent, newTotal), write)
  $result := 0
}

method main() returns ($result: Int)
  requires true
  ensures true
{
  var stress: Int
  var stressCaptured: Int
  var seed: Int
  var node: Ref
  var i: Int
  var current: Ref
  var _: Bool
  var _1: Bool
  var r: Int
  var rand_bool: Bool
  var _2: Int
  var _3: Bool
  var _4: Bool
  var r1: Int
  var rand_bool1: Bool
  var _5: Int
  var _6: Bool
  var current1: Ref
  var current2: Ref
  var current21: Ref
  stress := 0
  stressCaptured := stress + stress / 2 * 2
  seed := 1
  node := create_tree()
  i := 0
  while (i < stressCaptured)
    invariant 0 <= i && i <= stressCaptured && acc(tree(node), write) 
  {
    current := node
    _ := tree_has_left(current)
    if (_) {
      _1 := tree_has_right(current)
    }
    while (_ && _1)
      invariant acc(tree(current), write) 
    {
      r := rand(seed)
      seed := r
      _2 := mod(seed, stressCaptured)
      rand_bool := _2 <= stressCaptured / 2
      if (rand_bool) {
        current1 := tree_get_left(current)
      } else {
        current1 := tree_get_right(current)
      }
      _ := tree_has_left(current1)
      if (_) {
        _1 := tree_has_right(current1)
      }
      current := current1
    }
    _3 := tree_has_left(current)
    if (_3) {
      current2 := tree_add_right(current)
    } else {
      _4 := tree_has_right(current)
      if (_4) {
        current2 := tree_add_left(current)
      } else {
        r1 := rand(seed)
        seed := r1
        _5 := mod(seed, stressCaptured)
        rand_bool1 := _5 <= stressCaptured / 2
        if (rand_bool1) {
          current2 := tree_add_right(current)
        } else {
          current2 := tree_add_left(current)
        }
      }
    }
    _6 := tree_has_parent(current2)
    while (_6)
      invariant acc(tree(current2), write) 
    {
      current21 := tree_get_parent(current2)
      _6 := tree_has_parent(current21)
      current2 := current21
    }
    node := current2
    i := i + 1
    current := current2
  }
  $result := 0
}

method tree_add_left(node: Ref) returns ($result: Ref)
  requires acc(tree(node), write)
  ensures acc(tree($result), write)
{
  var n: Ref
  var nodeLeft: Ref
  var $result_0: Int
  unfold acc(tree(node), write)
  if (node == null) {
    fold acc(tree(node), write)
    $result := node
  } else {
    n := new(Node$total, Node$left, Node$right, Node$parent)
    n.Node$left := null
    n.Node$right := null
    n.Node$parent := node
    n.Node$total := 1
    fold acc(subtreeHelper(n.Node$left, n.Node$right, n, n.Node$total), write)
    nodeLeft := node.Node$left
    if (nodeLeft != null) {
      fold acc(tree(node), write)
      $result := node
    } else {
      unfold acc(subtreeHelper(nodeLeft, node.Node$right, node, node.Node$total), write)
      node.Node$left := n
      fold acc(context(n, node, 0), write)
      $result_0 := fixup_ancestors(n, node, 0, 1)
      fold acc(tree(n), write)
      $result := n
    }
  }
}

method tree_add_right(node: Ref) returns ($result: Ref)
  requires acc(tree(node), write)
  ensures acc(tree($result), write)
{
  var n: Ref
  var nodeRight: Ref
  var $result_0: Int
  unfold acc(tree(node), write)
  if (node == null) {
    fold acc(tree(node), write)
    $result := node
  } else {
    n := new(Node$total, Node$left, Node$right, Node$parent)
    n.Node$left := null
    n.Node$right := null
    n.Node$parent := node
    n.Node$total := 1
    fold acc(subtreeHelper(n.Node$left, n.Node$right, n, n.Node$total), write)
    nodeRight := node.Node$right
    if (nodeRight != null) {
      fold acc(tree(node), write)
      $result := node
    } else {
      unfold acc(subtreeHelper(node.Node$left, nodeRight, node, node.Node$total), write)
      node.Node$right := n
      fold acc(context(n, node, 0), write)
      $result_0 := fixup_ancestors(n, node, 0, 1)
      fold acc(tree(n), write)
      $result := n
    }
  }
}

method tree_get_left(node: Ref) returns ($result: Ref)
  requires acc(tree(node), write)
  ensures acc(tree($result), write)
{
  var left: Ref
  unfold acc(tree(node), write)
  if (node == null) {
    fold acc(tree(null), write)
    $result := null
  } else {
    left := node.Node$left
    if (left != null) {
      unfold acc(subtreeHelper(left, node.Node$right, node, node.Node$total), write)
      fold acc(context(left, node, left.Node$total), write)
    }
    fold acc(tree(left), write)
    $result := left
  }
}

method tree_get_parent(node: Ref) returns ($result: Ref)
  requires acc(tree(node), write)
  ensures acc(tree($result), write)
{
  var parent: Ref
  unfold acc(tree(node), write)
  if (node == null) {
    fold acc(tree(null), write)
    $result := null
  } else {
    parent := node.Node$parent
    if (parent == null) {
      fold acc(tree(null), write)
      $result := null
    } else {
      unfold acc(context(node, parent, node.Node$total), write)
      assert acc(context(parent, parent.Node$parent, parent.Node$total), write)
      fold acc(subtreeHelper(parent.Node$left, parent.Node$right, parent, parent.Node$total), write)
      fold acc(tree(parent), write)
      $result := parent
    }
  }
}

method tree_get_right(node: Ref) returns ($result: Ref)
  requires acc(tree(node), write)
  ensures acc(tree($result), write)
{
  var right: Ref
  unfold acc(tree(node), write)
  if (node == null) {
    fold acc(tree(null), write)
    $result := null
  } else {
    right := node.Node$right
    if (right != null) {
      unfold acc(subtreeHelper(node.Node$left, right, node, node.Node$total), write)
      fold acc(context(right, node, right.Node$total), write)
    }
    fold acc(tree(right), write)
    $result := right
  }
}

method tree_get_total(node: Ref) returns ($result: Int)
  requires acc(tree(node), write)
  ensures acc(tree(node), write)
{
  var _result$: Int
  unfold acc(tree(node), write)
  _result$ := 0
  if (node == null) {
    
  } else {
    _result$ := node.Node$total
  }
  fold acc(tree(node), write)
  $result := _result$
}

method tree_has_left(node: Ref) returns ($result: Bool)
  requires acc(tree(node), write)
  ensures acc(tree(node), write)
{
  var res: Bool
  var left: Ref
  unfold acc(tree(node), write)
  res := false
  if (node == null) {
    
  } else {
    left := node.Node$left
    res := left != null
  }
  fold acc(tree(node), write)
  $result := res
}

method tree_has_parent(node: Ref) returns ($result: Bool)
  requires acc(tree(node), write)
  ensures acc(tree(node), write)
{
  var res: Bool
  var parent: Ref
  unfold acc(tree(node), write)
  res := false
  if (node == null) {
    
  } else {
    parent := node.Node$parent
    res := parent != null
  }
  fold acc(tree(node), write)
  $result := res
}

method tree_has_right(node: Ref) returns ($result: Bool)
  requires acc(tree(node), write)
  ensures acc(tree(node), write)
{
  var res: Bool
  var right: Ref
  unfold acc(tree(node), write)
  res := false
  if (node == null) {
    
  } else {
    right := node.Node$right
    res := right != null
  }
  fold acc(tree(node), write)
  $result := res
}

method mod(r: Int, l: Int) returns ($result: Int)
{
  $result := 0
}

method rand(prev: Int) returns ($result: Int)
{
  $result := 0
}

method readStress() returns ($result: Int)
{
  $result := 0
}