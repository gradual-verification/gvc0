// List node
struct Node {
  int val;
  struct Node *next;
};

/*@
predicate sortedSegHelper(struct Node *start, struct Node *end, int prev, int endVal) =
  (start == end) ?
    ( (end == NULL) ? false : endVal >= prev )
    :
    (
      acc(start->val) && acc(start->next) &&
      start->val >= prev && sortedSegHelper(start->next, end, start->val, endVal)
    ) ;
@*/

/*@
// sorted seg predicate
predicate sortedSeg(struct Node *start, struct Node *end, int endVal) =
  (start == end) ?
    ( true )
    :
    (
      acc(start->val) && acc(start->next) &&
      sortedSegHelper(start->next, end, start->val, endVal)
    ) ;
@*/

/*@
predicate sorted(struct Node *list) =
  sortedSeg(list, NULL, -1);
@*/

//-------------------------------------------------------------------lemmas
// Lemma:
void appendLemmaLoopBody(struct Node *a, struct Node *b, struct Node *c, int aPrev, int cPrev, int bVal, int cVal)
  /*@
    requires ? &&
        ( (b == c) ? bVal == cVal : true ) &&
        ( (c == NULL) ?
            ( true )
            :
            ( acc(c->val) && acc(c->next) && c->val == cVal &&
              c->val >= cPrev && sortedSegHelper(c->next, NULL, c->val, -1)
            )
        ) &&
        ( (b == c) ?
            ( true )
            :
            (
              acc(b->val) && acc(b->next) && b->val == bVal &&
              sortedSegHelper(b->next, c, b->val, cVal)
            )
        ) ;
  @*/
  /*@
    ensures sortedSegHelper(a, c, aPrev, cVal) &&
        ( (c == NULL) ?
            ( true )
            :
            ( acc(c->val) && acc(c->next) && c->val == cVal &&
              c->val >= cPrev && sortedSegHelper(c->next, NULL, c->val, -1)
            )
        ) ;
  @*/
{
  if (b == c) {
  } else if (a == b) {
  } else {
    appendLemmaLoopBody(a->next, b, c, a->val, cPrev, bVal, cVal);
  }
}

void appendLemmaAfterLoopBody(struct Node *a, struct Node *b, struct Node *c, int aPrev, int bVal, int cVal)
  /*@
    requires ? &&
        ( (b == c) ? bVal == cVal : true ) &&
        ( (c == NULL) ? true : acc(c->val) && acc(c->next) && c->val == cVal ) &&
        ( (b == c) ?
            ( true )
            :
            (
              acc(b->val) && acc(b->next) && b->val == bVal &&
              sortedSegHelper(b->next, c, b->val, cVal)
            )
        ) ;
  @*/
  /*@
    ensures sortedSegHelper(a, c, aPrev, cVal) &&
        ( (c == NULL) ? true : acc(c->val) && acc(c->next) && c->val == cVal ) ;
  @*/
{
  if (b == c) {
  } else if (a == b) {
  } else {
    appendLemmaAfterLoopBody(a->next, b, c, a->val, bVal, cVal);
  }
}

//-------------------------------------------------------------------verified code starts below

struct Node *create_list(int val)
  //@ requires true;
  //@ ensures sorted(\result);
{
  struct Node *n = alloc(struct Node);
  n->val = val;
  n->next = NULL;
  return n;
}

struct Node *list_insert(struct Node *list, int val)
  //@ requires ?;
  //@ ensures sorted(\result);
{
  if (list == NULL || val <= list->val) {

    struct Node *n = alloc(struct Node);
    n->val = val;
    n->next = list;
    return n;

  } else {

    struct Node *curr = list;

    while (curr->next != NULL && curr->next->val < val)
     //@ loop_invariant acc(curr->val) && acc(curr->next);
     //@ loop_invariant sortedSeg(list, curr, curr->val) && curr->val <= val;
     //@ loop_invariant (curr->next == NULL) ? (true) : acc(curr->next->next) && acc(curr->next->val) && curr->next->val >= curr->val;
    {

      struct Node *prev = curr;
      curr = prev->next;

      if (list == prev) {
      } else {
        appendLemmaLoopBody(list->next, prev, curr, list->val, prev->val, prev->val, curr->val);
      }
    }

    struct Node *tmp = alloc(struct Node);
    tmp->val = val;
    tmp->next = curr->next;
    curr->next = tmp;

    if (list == curr) {
    } else {
      appendLemmaAfterLoopBody(list->next, curr, NULL, list->val, curr->val, -1);
    }

    return list;
  }
}

//---------------------------------------------------------------------main below

// main
int main()
  //@ requires true;
  //@ ensures true;
{
  int stress = 1;
  struct Node *l = create_list(3);
  int i = 0;
  while(i < stress)
  //@loop_invariant 0 <= i && i <= stress;
  {
    l = list_insert(l, 1);
    i += 1;
  }
  l = list_insert(NULL, 1);
  return 0;
}